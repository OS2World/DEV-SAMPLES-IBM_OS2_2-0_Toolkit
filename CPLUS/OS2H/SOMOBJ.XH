
/*
 * This file was generated by the SOM Compiler.
 * FileName: somobj.xh.
 * Generated using:
 *     SOM Precompiler spc: 1.22
 *     SOM Emitter emitxh: 1.11
 */

/*
 *  SOMObject: System Object Model root class
 *  Copyright (c) International Business Machines Corporation
 *                1991, 1992
 */

#ifndef somobj_xh
#define somobj_xh
class SOMObject;

/*
 *  This is the SOM root class, all SOM classes must be descended from
 *  <SOMObject>. <SOMObject> has no instance data so there is no
 *  per-instance cost to to being descended from it.
 */

#define SOMObject_MajorVersion 1
#define SOMObject_MinorVersion 1

/* C++ som defs */
#include <som.xh>
#include <somcls.API>

#ifndef SOMObject_API
#define SOMObject_API
/*
 * The Class API
 */

/* A procedure to create the SOMObject Class */
SOMEXTERN SOMClass * SOMLINK SOMObjectNewClass(
		integer4 majorVersion,
		integer4 minorVersion);

/* A macro to return the SOMObject class object */
#define _SOMObject ((SOMClass*)SOMObjectClassData.classObject)

/* The static interface to SOMObject and its instances */
SOMEXTERN struct SOMObjectClassDataStructure {
	SOMClass *classObject;
	somMToken somInit;
	somMToken somUninit;
	somMToken somFree;
	somMToken somMissingMethod;
	somMToken somGetClassName;
	somMToken somGetClass;
	somMToken somIsA;
	somMToken somRespondsTo;
	somMToken somIsInstanceOf;
	somMToken somGetSize;
	somMToken somDumpSelf;
	somMToken somDumpSelfInt;
	somMToken somPrintSelf;
	somMToken somFreeObj;
	somMToken somDispatchV;
	somMToken somDispatchL;
	somMToken somDispatchA;
	somMToken somDispatchD;
} SOMObjectClassData;

/*
 * -- Typedefs for Procedures that support SOMObject Methods
 */
extern "C" {
typedef void    (SOMLINK *somTD_SOMObject_somFree)(SOMObject *somSelf);
typedef void    (SOMLINK *somTD_SOMObject_somInit)(SOMObject *somSelf);
typedef void    (SOMLINK *somTD_SOMObject_somUninit)(SOMObject *somSelf);
typedef SOMClass *   (SOMLINK *somTD_SOMObject_somGetClass)(SOMObject *somSelf);
typedef zString    (SOMLINK *somTD_SOMObject_somGetClassName)(SOMObject *somSelf);
typedef integer4    (SOMLINK *somTD_SOMObject_somGetSize)(SOMObject *somSelf);
typedef int    (SOMLINK *somTD_SOMObject_somIsA)(SOMObject *somSelf,SOMClass *aClassObj);
typedef int    (SOMLINK *somTD_SOMObject_somIsInstanceOf)(SOMObject *somSelf,SOMClass *aClassObj);
typedef int    (SOMLINK *somTD_SOMObject_somRespondsTo)(SOMObject *somSelf,IN somId mId);
typedef void    (SOMLINK *somTD_SOMObject_somDispatchV)(SOMObject *somSelf,INOUT somId methodId,INOUT somId descriptor,...);
typedef integer4    (SOMLINK *somTD_SOMObject_somDispatchL)(SOMObject *somSelf,INOUT somId methodId,INOUT somId descriptor,...);
typedef void *   (SOMLINK *somTD_SOMObject_somDispatchA)(SOMObject *somSelf,INOUT somId methodId,INOUT somId descriptor,...);
typedef float8    (SOMLINK *somTD_SOMObject_somDispatchD)(SOMObject *somSelf,INOUT somId methodId,INOUT somId descriptor,...);
typedef SOMObject *   (SOMLINK *somTD_SOMObject_somPrintSelf)(SOMObject *somSelf);
typedef void    (SOMLINK *somTD_SOMObject_somDumpSelf)(SOMObject *somSelf,int level);
typedef void    (SOMLINK *somTD_SOMObject_somDumpSelfInt)(SOMObject *somSelf,int level);
}


#endif /* SOMObject_API */


/*
 * -- The C++ Wrapper Class for SOMObject
 */

class SOMObject
{
public:

void *operator new(size_t size)
{
   (void) size;
   if (!SOMObjectClassData.classObject) 
      SOMObjectNewClass(SOMObject_MajorVersion,SOMObject_MinorVersion);
   return (void *)
      ((somTD_SOMClass_somNew)
      somResolve(SOM_TestCls((SOMAny *)(SOMObjectClassData.classObject),
                             SOMClassClassData.classObject),
                 SOMClassClassData.somNew))
         ((SOMClass*)(SOMObjectClassData.classObject));
}

void operator delete(void * obj)
{
   ((SOMObject *)obj)->somFree();
}

/*
 *  Initialization / Termination group
 */

/* public method: somFree */

/*
 *  Releases the storage associated with <self>, assuming that <self>
 *  was created by <somNew> (or another class method that used
 *  <somNew>).  No future references should be made to <self>.  Will
 *  call <somUninit> on <self> before releasing the storage.
 * 
 *  This method must only be called on objects created by <somNew> (see
 *  the definition of <somClass>) and never on objects created by
 *  <somRenew>.
 * 
 *  It should not be necessary to override this method. (Override
 *  <somUninit> instead.)
 */
void    somFree()
{
   SOM_Resolve((SOMAny *)this,SOMObject,somFree)
	(this);
}


/* public method: somInit */

/*
 *  Initializes <self>.  As instances of <SOMObject> do not have any
 *  instance data there is nothing to initialize and you need not call
 *  this method.  It is provided to induce consistency among
 *  subclasses that require initialization.
 * 
 *  <somInit> is called automatically as a side effect of object
 *  creation (ie, by <somNew>).  If this effect is not desired, you
 *  can supply your own version of <somNew> (in a user-written metaclass)
 *  which does not invoke <somInit>.
 * 
 *  When overriding this method you should always call the parent class
 *  version of this method BEFORE doing your own initialization.
 */
void    somInit()
{
   SOM_Resolve((SOMAny *)this,SOMObject,somInit)
	(this);
}


/* public method: somUninit */

/*
 *  Un-initializes self.  As instances of <SOMObject> do not have any
 *  instance data there is nothing to un-initialize and you need not
 *  call this method.  It is provided to induce consistency among
 *  subclasses that require un-initialization.
 * 
 *  Use this method to clean up anything necessary such as dynamically
 *  allocated storage. However this method does not release the actual
 *  storage assigned to the object instance. This method is provided as
 *  a complement to <somFree> which also releases the storage
 *  associated with a dynamically allocated object. Usually you would
 *  just call <somFree> which will always call <somUninit>. However, in
 *  cases where <somRenew> (see the definition of <SOMClass>) was used
 *  to create an object instance, <somFree> cannot be called and you
 *  must call <somUninit> explicitly.
 * 
 *  When overriding this method you should always call the parentclass
 *  version of this method AFTER doing your own un-initialization.
 */
void    somUninit()
{
   SOM_Resolve((SOMAny *)this,SOMObject,somUninit)
	(this);
}


/* public method: somGetClass */

/*
 *  Returns this object's class object.
 */
SOMClass *   somGetClass()
{
   return (SOMClass*) SOM_Resolve((SOMAny *)this,SOMObject,somGetClass)
	(this);
}


/* public method: somGetClassName */

/*
 *  Returns a pointer to this object's class's name, as a NULL
 *  terminated string.
 * 
 *  It should not be necessary to override this method as it just
 *  invokes the class object's method (<somGetName>) to get the name.
 */
zString    somGetClassName()
{
   return (zString) SOM_Resolve((SOMAny *)this,SOMObject,somGetClassName)
	(this);
}


/* public method: somGetSize */

/*
 *  Returns the size of this instance in bytes.
 */
integer4    somGetSize()
{
   return (integer4) SOM_Resolve((SOMAny *)this,SOMObject,somGetSize)
	(this);
}


/* public method: somIsA */

/*
 *  Returns 1 (true) if <self>'s class is a descendent class of
 *  <aClassObj> and 0 (false) otherwise.  Note: a class object is
 *  considered to be descended from itself for the purposes of this
 *  method.
 */
int    somIsA(SOMClass *aClassObj)
{
   return (int) SOM_Resolve((SOMAny *)this,SOMObject,somIsA)
	(this,aClassObj);
}


/* public method: somIsInstanceOf */

/*
 *  Returns 1 (true) if <self> is an instance of the specified
 *  <aClassObj> and 0 (false) otherwise.
 */
int    somIsInstanceOf(SOMClass *aClassObj)
{
   return (int) SOM_Resolve((SOMAny *)this,SOMObject,somIsInstanceOf)
	(this,aClassObj);
}


/* public method: somRespondsTo */

/*
 *  Returns 1 (true) if the indicated method is supported by this
 *  object's class and 0 (false) otherwise.
 */
int    somRespondsTo(IN somId mId)
{
   return (int) SOM_Resolve((SOMAny *)this,SOMObject,somRespondsTo)
	(this,mId);
}


/*
 *  These methods make it easier for very dynamic domains to bind to
 *  the SOM object protocol boundry.
 * 
 *  These methods determine the appropriate method procedure and then
 *  call it with the arguments specified.  The default implementation
 *  of these methods provided in this class simply lookup the method by
 *  name and call it.  However, other classes may choose to implement
 *  any form of lookup they wish.  For example, one could provide an
 *  implementation of these methods that used the CLOS form of method
 *  resolution. For domains that can do so it will generally be much
 *  faster to invoke their methods directly rather than going through a
 *  dispatch method.  However, all methods are reachable through the
 *  dispatch methods.  SOM provides a small set of external procedures
 *  that wrap these method calls so that the caller need never do method
 *  resolution.
 * 
 *  These methods are declared to take a variable length argument list,
 *  but like all such methods the SOM object protocol boundry requires
 *  that the variable part of the argument list be assembled into the
 *  standard, platform-specific, data structure for variable argument
 *  lists before the method is actually invoked.  This can be very
 *  useful in domains that need to construct the argument list at
 *  runtime. As they can invoke methods without being able to put the
 *  constructed arguments in the normal form for a call.  This is
 *  helpful because such an operation is usually impossible in most
 *  high level languages and platform-specific assembler language
 *  routines would have to be used.
 * 
 *  Note: It was decided to have different methods for different return
 *  value shapes. This avoids the memory mangement problems that would
 *  arise in some domains if an additional parameter was required to
 *  carry the return value.
 * 
 *  Note: SOM does not support return values except for the four
 *  families shown below. Within a family (such as integer) SOM only
 *  supports the largest member.
 */

/* public method: somDispatchV */

/*
 *  Does not return a value.
 */

/* the va_list invocation form */
void    SOMObject_somDispatchV(INOUT somId methodId,
		INOUT somId descriptor,
		va_list ap)
{
   SOM_Resolve((SOMAny *)this,SOMObject,somDispatchV)
	(this,methodId,descriptor,ap);
}

/* the varargs invocation form */
void    somDispatchV(INOUT somId methodId,
		INOUT somId descriptor,
		...)
{
   va_list ap;
   va_start(ap, descriptor);
   SOM_Resolve((SOMAny *)this,SOMObject,somDispatchV)
	(this,methodId,descriptor,ap);
   va_end(ap);
}


/* public method: somDispatchL */

/*
 *  Returns a 4 byte quanity in the normal manner that integer data is
 *  returned. This 4 byte quanity can, of course, be something other
 *  than an integer.
 */

/* the va_list invocation form */
integer4    SOMObject_somDispatchL(INOUT somId methodId,
		INOUT somId descriptor,
		va_list ap)
{
   return SOM_Resolve((SOMAny *)this,SOMObject,somDispatchL)
	(this,methodId,descriptor,ap);
}

/* the varargs invocation form */
integer4    somDispatchL(INOUT somId methodId,
		INOUT somId descriptor,
		...)
{
   va_list ap;
   va_start(ap, descriptor);
   integer4 result = 
      (integer4) SOM_Resolve((SOMAny *)this,SOMObject,somDispatchL)
	(this,methodId,descriptor,ap);
   va_end(ap);
   return result;
}


/* public method: somDispatchA */

/*
 *  Returns a data structure address in the normal manner that such data is
 *  returned.
 */

/* the va_list invocation form */
void *   SOMObject_somDispatchA(INOUT somId methodId,
		INOUT somId descriptor,
		va_list ap)
{
   return SOM_Resolve((SOMAny *)this,SOMObject,somDispatchA)
	(this,methodId,descriptor,ap);
}

/* the varargs invocation form */
void *   somDispatchA(INOUT somId methodId,
		INOUT somId descriptor,
		...)
{
   va_list ap;
   va_start(ap, descriptor);
   void* result = 
      (void*) SOM_Resolve((SOMAny *)this,SOMObject,somDispatchA)
	(this,methodId,descriptor,ap);
   va_end(ap);
   return result;
}


/* public method: somDispatchD */

/*
 *  Returns a 8 byte quanity in the normal manner that floating point
 *  data is returned.
 */

/* the va_list invocation form */
float8    SOMObject_somDispatchD(INOUT somId methodId,
		INOUT somId descriptor,
		va_list ap)
{
   return SOM_Resolve((SOMAny *)this,SOMObject,somDispatchD)
	(this,methodId,descriptor,ap);
}

/* the varargs invocation form */
float8    somDispatchD(INOUT somId methodId,
		INOUT somId descriptor,
		...)
{
   va_list ap;
   va_start(ap, descriptor);
   float8 result = 
      (float8) SOM_Resolve((SOMAny *)this,SOMObject,somDispatchD)
	(this,methodId,descriptor,ap);
   va_end(ap);
   return result;
}


/*
 *  The methods in this group are provided to support program
 *  development.  They have been defined in such a way that most
 *  development contexts will find them easy to expoit. However, some
 *  contexts may need to customize their I/O facilities. We have
 *  attempted to allow this customization in a very portable manner,
 *  however not all contexts will be able to perform the customization
 *  operations directly because they require passing function
 *  parameters. We chose this approach because it allows great
 *  platform-neutral flexibility and we felt that any provider of
 *  development support would find it reasonable to provide the
 *  customizations necessary for her/his specific development
 *  environment.
 * 
 *  The chosen approach relies on a character output routine.  An
 *  external variable, <SOMOutCharRoutine>, points to this routine.  The
 *  SOM environment provides an implementation of this routine that should
 *  work in most development environments (it writes to the standard output
 *  stream).  A development context can, however, assign a new value to
 *  <SOMOutCharRoutine> and thereby redefine the output process.  SOM
 *  provides no special support for doing this assigment.
 */

/* public method: somPrintSelf */

/*
 *  Uses <SOMOutCharRoutine> to write a brief string with identifying
 *  information about this object.  The default implementation just gives
 *  the object's class name and its address in memory.
 *  <self> is returned.
 */
SOMObject *   somPrintSelf()
{
   return (SOMObject*) SOM_Resolve((SOMAny *)this,SOMObject,somPrintSelf)
	(this);
}


/* public method: somDumpSelf */

/*
 *  Uses <SOMOutCharRoutine> to write a detailed description of this object
 *  and its current state.
 * 
 *  <level> indicates the nesting level for describing compound objects
 *  it must be greater than or equal to zero.  All lines in the
 *  description will be preceeded by <2*level> spaces.
 * 
 *  This routine only actually writes the data that concerns the object
 *  as a whole, such as class, and uses <somDumpSelfInt> to describe
 *  the object's current state.  This approach allows readable
 *  descriptions of compound objects to be constructed.
 * 
 *  Generally it is not necessary to override this method, if it is
 *  overriden it generally must be completely replaced.
 */
void    somDumpSelf(int level)
{
   SOM_Resolve((SOMAny *)this,SOMObject,somDumpSelf)
	(this,level);
}


/* public method: somDumpSelfInt */

/*
 *  Uses <SOMOutCharRoutine> to write out the current state of this object.
 *  Generally this method will need to be overridden.  When overriding
 *  it, begin by calling the parent class form of this method and then
 *  write out a description of your class's instance data. This will
 *  result in a description of all the object's instance data going
 *  from its root ancestor class to its specific class.
 */
void    somDumpSelfInt(int level)
{
   SOM_Resolve((SOMAny *)this,SOMObject,somDumpSelfInt)
	(this,level);
}



};   /* SOMObject */



#endif       /* somobj_xh */
